//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Vector {

  [MarshalAs(UnmanagedType.R4)]
  private float _x;

  [MarshalAs(UnmanagedType.R4)]
  private float _y;

  public float X {
    get { return this._x; }
    set { this._x = value; }
  }

  public float Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public Vector(float x, float y) {
    this._x = x;
    this._y = y;
  }

  public float Length {
    get { return (float)Math.Sqrt(LengthSquared); }
  }

  public float LengthSquared {
    get { return this._x * this._x + this._y * this._y; }
  }

  public void Normalize() {
    this /= this.Length;
  }

  public static float CrossProduct(Vector v0, Vector v1) {
    return v0._x * v1._y - v0._y * v1._x;
  }

  public static float AngleBetween(Vector v0, Vector v1) {
    float sin = v0._x * v1._y - v1._x * v0._y;
    float cos = v0._x * v1._x + v0._y * v1._y;
    return (float)(Math.Atan2(sin, cos) * (180 / Math.PI));
  }

  public static Vector operator-(Vector vector) {
    return new Vector(-vector._x, -vector._y);
  }

  public void Negate() {
    _x = -_x;
    _y = -_y;
  }

  public static Vector operator+(Vector v0, Vector v1) {
    return new Vector(v0._x + v1._x, v0._y + v1._y);
  }

  public static Vector Add(Vector v0, Vector v1) {
    return new Vector(v0._x + v1._x, v0._y + v1._y);
  }

  public static Vector operator-(Vector v0, Vector v1) {
    return new Vector(v0._x - v1._x, v0._y - v1._y);
  }

  public static Vector Subtract(Vector v0, Vector v1) {
    return new Vector(v0._x - v1._x, v0._y - v1._y);
  }

  public static Point operator+(Vector vector, Point point) {
    return new Point(point.X + vector._x, point.Y + vector._y);
  }

  public static Point Add(Vector vector, Point point) {
    return new Point(point.X + vector._x, point.Y + vector._y);
  }

  public static Vector operator*(Vector vector, float scalar) {
    return new Vector(vector._x * scalar, vector._y * scalar);
  }

  public static Vector Multiply(Vector vector, float scalar) {
    return new Vector(vector._x * scalar, vector._y * scalar);
  }

  public static Vector operator*(float scalar, Vector vector) {
    return new Vector(vector._x * scalar, vector._y * scalar);
  }

  public static Vector Multiply(float scalar, Vector vector) {
    return new Vector(vector._x * scalar, vector._y * scalar);
  }

  public static Vector operator/(Vector vector, float scalar) {
    return vector * (1.0f / scalar);
  }

  public static Vector Divide(Vector vector, float scalar) {
    return vector * (1.0f / scalar);
  }

  public static float operator*(Vector v0, Vector v1) {
    return v0._x * v1._x + v0._y * v1._y;
  }

  public static float Multiply(Vector v0, Vector v1) {
    return v0._x * v1._x + v0._y * v1._y;
  }

  public static float Determinant(Vector v0, Vector v1) {
    return v0._x * v1._y - v0._y * v1._x;
  }

  public static explicit operator Size(Vector vector) {
    return new Size(Math.Abs(vector._x), Math.Abs(vector._y));
  }

  public static explicit operator Point(Vector vector) {
    return new Point(vector._x, vector._y);
  }

  public static bool operator==(Vector v0, Vector v1) {
    return v0._x == v1._x && v0._y == v1._y;
  }

  public static bool operator!=(Vector v0, Vector v1) {
    return !(v0 == v1);
  }

  public static bool Equals(Vector v0, Vector v1) {
    return v0 == v1;
  }

  public override bool Equals(object o) {
    return o is Vector && this == (Vector)o;
  }

  public bool Equals(Vector value) {
    return Vector.Equals(this, value);
  }

  public override int GetHashCode() {
    return this.X.GetHashCode() ^ this.Y.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1}", X, Y);
  }

  public static Vector Parse(string str) {
    Point p;
    if (Point.TryParse(str, out p)) {
      return new Vector(p.X, p.Y);
    }
    throw new ArgumentException("Cannot create Vector from '" + str + "'");
  }

}

}

